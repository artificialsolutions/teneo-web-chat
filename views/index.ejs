<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>Teneo Web Chat</title>
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0 user-scalable=no" />
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=" />
<style>

body {
    background: #E5F5FE;
}
.centerimage {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 400px;
    height: 300px;
    margin-top: -150px;
    margin-left: -200px;
    z-index: -10;
}
.btn {
    margin-bottom: 5px;
}
@media (max-width: 500px) {
    .centerimage {
        opacity: 0.3;
        transition-property: opacity;
        transition-duration: 0.2s;
        transition-timing-function: linear;
    }
}


div.scroll {
    width: 600px;
    overflow-x: hidden;
    text-align: justify;
}

</style>

<!-- script src="teneo-web-chat.js"></script -->

</head>

<body>
<button onclick="TeneoWebChat.call('reset')">Reset Chat</button>

<!--

<br/>
<h3>Messages</h3>
<button class="btn" onclick="TeneoWebChat.call('add_message',textMessageAgent)">Message from agent</button><br>

<h3>Messages with avatar</h3>
<button class="btn" onclick="TeneoWebChat.call('add_message',textMessageUserAvatar)">Message from user</button><br>
<button class="btn" onclick="TeneoWebChat.call('add_message',textMessageBotAvatar)">Message from bot</button><br>
<button class="btn" onclick="TeneoWebChat.call('add_message',textMessageAgentAvatar)">Message from agent</button><br>

<h3>Messages with avatar and dateline</h3>
<button class="btn" onclick="TeneoWebChat.call('add_message',textMessageUserAvatarDateline)">Message from user</button><br>
<button class="btn" onclick="TeneoWebChat.call('add_message',textMessageBotAvatarDateline)">Message from bot</button><br>
<button class="btn" onclick="TeneoWebChat.call('add_message',textMessageAgentAvatarDateline)">Message from agent</button><br>

<h3>Typing indicators</h3>
<button class="btn" onclick="TeneoWebChat.call('show_typing_indicator',typingIndicatorAgent)">Show agent typing indicator</button><br>
<button class="btn" onclick="TeneoWebChat.call('show_typing_indicator',typingIndicatorBot)">Show bot typing indicator</button><br>
<button class="btn" onclick="TeneoWebChat.call('show_typing_indicator',typingIndicatorUser)">Show user typing indicator</button><br>

<button class="btn" onclick="TeneoWebChat.call('hide_typing_indicator',{'author': 'agent'})">Hide agent typing indicator</button><br>
<button class="btn" onclick="TeneoWebChat.call('hide_typing_indicator',{'author': 'bot'})">Hide bot typing indicator</button><br>
<button class="btn" onclick="TeneoWebChat.call('hide_typing_indicator',{'author': 'user'})">Hide user typing indicator</button><br>

<h3>Other</h3>
<button class="btn" onclick="TeneoWebChat.call('disable_user_input')">Disable user input</button><br>
<button class="btn" onclick="TeneoWebChat.call('enable_user_input')">Enable user input</button><br>
<button class="btn" onclick="TeneoWebChat.call('maximize')">Maximize</button><br>
<button class="btn" onclick="TeneoWebChat.on('visibility_changed', function(){console.log('Bad button')})">Bad button!</button>

-->

<div class="scroll">
    This is a Dummy Paragraph to test vertical and horizontal scrolling. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Kokruous maximus et blandit diam. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Mauris non ex eget augue lobortis iaculis id a mauris. Sed auctor est quis lectus fringilla pharetra. Mauris efficitur nulla at augue porttitor laoreet. Duis pharetra lectus et fermentum commodo. Sed ullamcorper ante lectus, sit amet facilisis erat auctor quis. Mauris varius pharetra velit, in varius leo consequat sed. Aenean porta lorem non neque feugiat, nec ultrices est commodo. Ut vulputate quis neque sed tincidunt. Suspendisse in ligula accumsan, pharetra libero id, dignissim felis. Morbi scelerisque lacus sed ipsum faucibus suscipit. Vestibulum vitae efficitur nunc. Etiam ornare, risus nec dictum condimentum, ipsum tellus condimentum neque, vitae tempus velit tortor et magna. Vivamus egestas porta lacinia. Aenean interdum, dui ut maximus varius, massa ligula efficitur ex, eget cursus dui diam eget est.
    Nam quis felis quis ipsum vulputate lobortis vel laoreet mauris. Sed vel nisi quam. Enean id vestibulum lacus, ac faucibus velit. Donec blandit eros dui, ac imperdiet leo convallis vel. Integer molestie purus in placerat varius. Morbi porta porta varius. Nam odio quam, porttitor quis scelerisque nec, sollicitudin a orci. Interdum et malesuada fames ac ante ipsum primis in faucibus.
</div>

<div id="teneo-web-chat"></div>


<script>
/* <![CDATA[ */
window.addEventListener('load', () => {



TeneoWebChat.on('ready', () => {
    const x = TeneoWebChat.get('storage').getItem('twc_last_state');
    if (x) {
        switch (x) {
            case 'maximized':
            TeneoWebChat.call('maximize');
                break;
            case 'minimized':
            TeneoWebChat.call('minimize');
                break;
            default:
                logger.warn('TeneoWebChat', 'unknown stored twc_last_state value', x);
        }
    }
});

TeneoWebChat.on('visibility_changed', payload => TeneoWebChat.get('storage').setItem('twc_last_state', payload.visibility));

TeneoWebChat.on('reset', () => TeneoWebChat.get('storage').removeItem('twc_last_state'));

// ============================================================

TeneoWebChat.on('upload_button_clicked', () => TeneoWebChat.call('show_upload_panel'));

/*
TeneoWebChat.call('show_upload_panel');4
TeneoWebChat.call('hide_upload_panel');
*/

// ============================================================

(() => {



// TODO Re-implement the fileUploader object for your file upload service!
// It should have public methods start(item) to start the asynchronous
// file upload and calcelAll() to cancel all the initiated but not yet finished
// files uploads.
const fileUploader = {

    itemIdToUploadProcessId: null,
    itemIdToProgressTickerId: null,

    upload(item, callbacks) {
        if (this.itemIdToUploadProcessId == null) this.itemIdToUploadProcessId = {};
        if (this.itemIdToProgressTickerId == null) this.itemIdToProgressTickerId = {};

        var nUploadPercentage = 0;

        const bFileUploadSuccessful = Math.random() < 0.5,
        delayMillis = Math.random() * 20000,
        tickerInterval = delayMillis / (bFileUploadSuccessful || Math.random() < 0.5 ? 10 : 10 * Math.random()),
        stopTicker = () => {
            clearInterval(this.itemIdToProgressTickerId[item.id]);
            delete this.itemIdToProgressTickerId[item.id];
        },
        updateUploadPercentage = () => {
            callbacks.onUploadPersentageChanged(nUploadPercentage);
            if (nUploadPercentage < 100) nUploadPercentage += 10;
            else stopTicker();
        };

        updateUploadPercentage();
        this.itemIdToProgressTickerId[item.id] = setInterval(updateUploadPercentage, tickerInterval);

        this.itemIdToUploadProcessId[item.id] = setTimeout(() => {
            stopTicker();
            delete this.itemIdToUploadProcessId[item.id];
            if (bFileUploadSuccessful) callbacks.onSuccess();
            else callbacks.onFailure(new Error('Upload failure'));
        }, delayMillis);
    },

    cancel(item) {
        if (this.itemIdToUploadProcessId) {
            clearTimeout(this.itemIdToUploadProcessId[item.id]);
            delete this.itemIdToUploadProcessId[item.id];
        }
        if (this.itemIdToProgressTickerId) {
            clearInterval(this.itemIdToProgressTickerId[item.id]);
            delete this.itemIdToProgressTickerId[item.id];
        }
    },

    cancelAll() {
        // TODO Implement here the cancellation of all the started
        // but not finished file upload processes 
        if (this.itemIdToUploadProcessId) {
            Object.values(this.itemIdToUploadProcessId).forEach(processId => clearTimeout(processId));
            this.itemIdToUploadProcessId = null;
        }
        if (this.itemIdToProgressTickerId) {
            Object.values(this.itemIdToProgressTickerId).forEach(processId => clearInterval(processId));
            this.itemIdToProgressTickerId = null;
        }
    }
};


var itemIdToUploadState;


const clearFileUploads = () => {
    fileUploader.cancelAll();
    itemIdToUploadState = null;
    TeneoWebChat.get('storage').removeItem('twc_itemIdToUploadState');
},


outputBotText = sText => TeneoWebChat.call('add_message', {
    type: 'text',
    author: 'bot',
    data: { text: sText }
});


TeneoWebChat.on('ready', () => {
    var x = TeneoWebChat.get('storage').getItem('twc_itemIdToUploadState');
    if (!x || (x = x.trim()).length === 0) return;
    try {
        itemIdToUploadState = JSON.parse(x);
        if (itemIdToUploadState == null || typeof itemIdToUploadState !== 'object' || Array.isArray(itemIdToUploadState)) {
            console.warn('Bad twc_itemIdToUploadState value [ ' + x + ' ], should be an object');
            itemIdToUploadState = null;
            return;
        }
    } catch(err) {
        console.warn('Bad twc_itemIdToUploadState value [ ' + x + ' ]', err);
        return;
    }
    var uploadState, bChanged;
    for (x in itemIdToUploadState) {
        if (itemIdToUploadState.hasOwnProperty(x)) {
            uploadState = itemIdToUploadState[x];
            if (uploadState.status === 'IN_PROGRESS') {
                uploadState.status = 'INTERRUPTED';
                bChanged = true;
            } else if (uploadState.status !== 'SUCCEEDED' && uploadState.controlAllowed) {
                uploadState.controlAllowed = false;
                bChanged = true;
            }
        }
    }
    if (bChanged) {
        TeneoWebChat.get('storage').setItem('twc_itemIdToUploadState', JSON.stringify(itemIdToUploadState));
    }
    setTimeout(() => {
        for (x in itemIdToUploadState) {
            if (itemIdToUploadState.hasOwnProperty(x)) {
                uploadState = itemIdToUploadState[x];
                TeneoWebChat.call('set_upload_state', {
                    itemId: x,
                    uploadState: {
                        status: uploadState.status,
                        controlAllowed: uploadState.controlAllowed
                    }
                });
            }
        }
    });
});


TeneoWebChat.on('upload_panel_submit', payload => {
    console.log('upload_panel_submit', payload);
    if (itemIdToUploadState == null) itemIdToUploadState = {};
    payload.items.forEach(item => {
        itemIdToUploadState[item.id] = {
            status: 'IN_PROGRESS',
            controlAllowed: true
        };
        TeneoWebChat.call('add_message', {
            type: 'upload',
            data: {
                itemId: item.id,
                fileName: item.file.name,
                fileSymbol: item.file.name.substring(item.file.name.lastIndexOf('.') + 1),
                initialUploadState: {
                    status: 'IN_PROGRESS',
                    controlAllowed: true
                }
            }
        });
        fileUploader.upload(item, {
            onUploadPersentageChanged: nUploadPercentage => {
                TeneoWebChat.call('set_upload_state', {
                    itemId: item.id,
                    uploadState: {
                        uploadPercentage: nUploadPercentage
                    }
                });
            }, onSuccess: () => {
                TeneoWebChat.call('set_upload_state', {
                    itemId: item.id,
                    uploadState: {
                        status: 'SUCCEEDED',
                        uploadPercentage: 0
                    }
                });
            }, onFailure: err => {
                TeneoWebChat.call('set_upload_state', {
                    itemId: item.id,
                    uploadState: {
                        status: 'FAILED',
                        uploadPercentage: 0
                    }
                });
            }
        });
    });
    TeneoWebChat.get('storage').setItem('twc_itemIdToUploadState', JSON.stringify(itemIdToUploadState));
});


TeneoWebChat.on('upload_panel_cancel', payload => {
    console.log('upload_panel_cancel', payload);
    outputBotText('You have canceled on ' + payload.itemsCount + ' files');
});


TeneoWebChat.on('reset', clearFileUploads);


})();



(() => {

var storage, delayId, messageQueue, bAlreadyStarted, bHeadBeingProcessed;


const splitter = /\s*\|\|\s*/m, typingIndicator = { author: 'bot' },

MESSAGE_QUEUE = 'twc_responseDelay_messageQueue',
ALREADY_STARTED = 'twc_responseDelay_alreadyStarted',

stringAsBoolean = s => s && (s = s.trim()).length !== 0 && s != 0 && s.toLowerCase() !== 'false',


queueMessage = message => {
    messageQueue.push(message);
    storage.setItem(MESSAGE_QUEUE, JSON.stringify(messageQueue));
},


queueTextsAsBotMessages = tt => {
    for (var i = 0; i < tt.length; i++) {
        messageQueue.push({
            type: 'text',
            author: 'bot',
            data: { text: tt[i] }
        });
    }
    storage.setItem(MESSAGE_QUEUE, JSON.stringify(messageQueue));
},


processQueuedMessages = () => {
    if (messageQueue.length === 0 || bHeadBeingProcessed) return;
    bHeadBeingProcessed = true;
    const m = messageQueue[0];
    var x;
    if (bAlreadyStarted) {
        if (m.type === 'system') x = 0;
        else {
            TeneoWebChat.call('show_typing_indicator', typingIndicator);
            x = m.data.text;
            x = ('string' === typeof x) ? 1400 * (x.length / (x.length + 50)) + 600 : 1000;
        }
    } else {
        storage.setItem(ALREADY_STARTED, '1');
        bAlreadyStarted = true;
        x = 0;
    }
    delayId = setTimeout(() => {
        TeneoWebChat.call('hide_typing_indicator', typingIndicator);
        messageQueue.shift();
        bHeadBeingProcessed = false;
        m.data._responseDelayExtensionProcessed = true;
        TeneoWebChat.call('add_message', m);
        if (messageQueue.length === 0) {
            storage.setItem(MESSAGE_QUEUE, '');
            delayId = null;
        } else {
            storage.setItem(MESSAGE_QUEUE, JSON.stringify(messageQueue));
            setTimeout(processQueuedMessages);
        }
    }, x);
},


rushQueuedMessages = () => {
    if (messageQueue.length === 0) return;
    if (delayId != null) {
        clearTimeout(delayId);
        delayId = null;
    }
    TeneoWebChat.call('hide_typing_indicator', typingIndicator);
    messageQueue.forEach(m => {
        m.data._responseDelayExtensionProcessed = true;
        TeneoWebChat.call('add_message', m);
    });
    messageQueue = [];
    storage.setItem(MESSAGE_QUEUE, '');
    bHeadBeingProcessed = false;
};


TeneoWebChat.on('ready', () => {
    storage = TeneoWebChat.get('storage');
    bAlreadyStarted = stringAsBoolean(storage.getItem(ALREADY_STARTED));
    messageQueue = storage.getItem(MESSAGE_QUEUE);
    if (messageQueue == null || (messageQueue = messageQueue.trim()).length === 0) messageQueue = [];
    else {
        try {
            messageQueue = JSON.parse(messageQueue);
            if (Array.isArray(messageQueue)) processQueuedMessages();
            else {
                console.warn(MESSAGE_QUEUE + ' value is not an array', messageQueue);
                storage.removeItem(MESSAGE_QUEUE);
                messageQueue = [];
            }
        } catch (err) {
            console.warn(MESSAGE_QUEUE + ' value [ ' + messageQueue + ' ] could not be parsed', err);
            storage.removeItem(MESSAGE_QUEUE);
            messageQueue = [];
        }
    }
});


TeneoWebChat.on('new_message', payload => {
    const m = payload.message;
    if (m.data._responseDelayExtensionProcessed) return;
    payload.handledState.handled = true;
    if (m.author === 'bot' || !m.author) {
        if (m.type === 'text') {
            const tt = m.data.text.split(splitter);
            if (tt.length === 1) queueMessage(m);
            else queueTextsAsBotMessages(tt);
        } else {
            queueMessage(m);
        }
        processQueuedMessages();
    } else {
        rushQueuedMessages();
        bAlreadyStarted = true;
        storage.setItem(ALREADY_STARTED, '1');
        m.data._responseDelayExtensionProcessed = true;
        TeneoWebChat.call('add_message', m);
    }
});


TeneoWebChat.on('reset', () => {
    if (delayId != null) {
        clearTimeout(delayId);
        delayId = null;
    }
    messageQueue = [];
    bAlreadyStarted = false;
    bHeadBeingProcessed = false;
    storage.removeItem(MESSAGE_QUEUE);
    storage.removeItem(ALREADY_STARTED);
});

})();


// ============================================================

const element = document.getElementById('teneo-web-chat');
const teneoProps = {
    'teneoEngineUrl': '<%= process.env.TENEO_ENGINE_URL %>',
    'title': '<%= process.env.HEADER_TITLE %>',
    'titleIconUrl': '<%= process.env.HEADER_ICON_URL %>',
    'showCloseButton': '<%= process.env.SHOW_CLOSE_BUTTON %>',
    'agentAvatarUrl': '<%= process.env.AGENT_AVATAR_URL %>',
    'botAvatarUrl': '<%= process.env.BOT_AVATAR_URL %>',
    'userAvatarUrl': '<%= process.env.USER_AVATAR_URL %>',
    'minimizeIconUrl': '<%= process.env.MINIMIZE_ICON_URL %>',
    'closeIconUrl': '<%= process.env.CLOSE_ICON_URL %>',
    'launchIconUrl': '<%= process.env.LAUNCH_ICON_URL %>',
    'sendIconUrl': '<%= process.env.SEND_ICON_URL %>',
    'uploadIconUrl': '<%= process.env.UPLOAD_ICON_URL %>',
    'showUploadButton': '<%= process.env.SHOW_UPLOAD_BUTTON %>',
    'asrIconUrl': '<%= process.env.ASR_ICON_URL %>',
    'showAsrButton': '<%= process.env.SHOW_ASR_BUTTON %>',
    'asrActive': '<%= process.env.ASR_ACTIVE %>',
    'ttsIconUrl': '<%= process.env.TTS_ICON_URL %>',
    'showTtsButton': '<%= process.env.SHOW_TTS_BUTTON %>',
    'ttsActive': '<%= process.env.TTS_ACTIVE %>',
    'msCognitiveSubscriptionKey': '<%= process.env.MS_COGNITIVE_SUBSCRIPTION_KEY %>',
    'msCognitiveRegion': '<%= process.env.MS_COGNITIVE_REGION %>',
    'msVoice': '<%= process.env.MS_VOICE %>',
    'locale': '<%= process.env.LOCALE %>',
    'autoRedirect': '<%= process.env.AUTO_OUTPUT_LINK_REDIRECT %>'
};

window.TeneoWebChat.initialize(element, teneoProps);


});
/* ]]> */
</script>
    

</body>
</html>
